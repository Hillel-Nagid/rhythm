{"ast":null,"code":"!function (e) {\n  if (\"object\" == typeof exports && \"undefined\" != typeof module) module.exports = e();else if (\"function\" == typeof define && define.amd) define([], e);else {\n    var f;\n    false ? f = window : \"undefined\" != typeof global ? f = global : \"undefined\" != typeof self && (f = self), f.BandJS = e();\n  }\n}(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          throw new Error(\"Cannot find module '\" + o + \"'\");\n        }\n\n        var f = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(f.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, f, f.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof require == \"function\" && require;\n\n    for (var o = 0; o < r.length; o++) s(r[o]);\n\n    return s;\n  }({\n    1: [function (_dereq_, module, exports) {\n      /*\r\n       * Web Audio API AudioContext shim\r\n       */\n      (function (definition) {\n        if (typeof exports === \"object\") {\n          module.exports = definition();\n        }\n      })(function () {\n        return window.AudioContext || window.webkitAudioContext;\n      });\n    }, {}],\n    2: [function (_dereq_, module, exports) {\n      /**\r\n       * Band.js - Music Composer\r\n       * An interface for the Web Audio API that supports rhythms, multiple instruments, repeating sections, and complex\r\n       * time signatures.\r\n       *\r\n       * @author Cody Lundquist (http://github.com/meenie) - 2014\r\n       */\n      module.exports = Conductor;\n      var packs = {\n        instrument: {},\n        rhythm: {},\n        tuning: {}\n      };\n      /**\r\n       * Conductor Class - This gets instantiated when `new BandJS()` is called\r\n       *\r\n       * @param tuning\r\n       * @param rhythm\r\n       * @constructor\r\n       */\n\n      function Conductor(tuning, rhythm) {\n        if (!tuning) {\n          tuning = 'equalTemperament';\n        }\n\n        if (!rhythm) {\n          rhythm = 'northAmerican';\n        }\n\n        if (typeof packs.tuning[tuning] === 'undefined') {\n          throw new Error(tuning + ' is not a valid tuning pack.');\n        }\n\n        if (typeof packs.rhythm[rhythm] === 'undefined') {\n          throw new Error(rhythm + ' is not a valid rhythm pack.');\n        }\n\n        var conductor = this,\n            player,\n            noop = function () {},\n            AudioContext = _dereq_('audiocontext'),\n            signatureToNoteLengthRatio = {\n          2: 6,\n          4: 3,\n          8: 4.50\n        };\n\n        conductor.packs = packs;\n        conductor.pitches = packs.tuning[tuning];\n        conductor.notes = packs.rhythm[rhythm];\n        conductor.audioContext = new AudioContext();\n        conductor.masterVolumeLevel = null;\n        conductor.masterVolume = conductor.audioContext.createGain();\n        conductor.masterVolume.connect(conductor.audioContext.destination);\n        conductor.beatsPerBar = null;\n        conductor.noteGetsBeat = null;\n        conductor.tempo = null;\n        conductor.instruments = [];\n        conductor.totalDuration = 0;\n        conductor.currentSeconds = 0;\n        conductor.percentageComplete = 0;\n        conductor.noteBufferLength = 20;\n        conductor.onTickerCallback = noop;\n        conductor.onFinishedCallback = noop;\n        conductor.onDurationChangeCallback = noop;\n        /**\r\n         * Use JSON to load in a song to be played\r\n         *\r\n         * @param json\r\n         */\n\n        conductor.load = function (json) {\n          // Clear out any previous song\n          if (conductor.instruments.length > 0) {\n            conductor.destroy();\n          }\n\n          if (!json) {\n            throw new Error('JSON is required for this method to work.');\n          } // Need to have at least instruments and notes\n\n\n          if (typeof json.instruments === 'undefined') {\n            throw new Error('You must define at least one instrument');\n          }\n\n          if (typeof json.notes === 'undefined') {\n            throw new Error('You must define notes for each instrument');\n          } // Shall we set a time signature?\n\n\n          if (typeof json.timeSignature !== 'undefined') {\n            conductor.setTimeSignature(json.timeSignature[0], json.timeSignature[1]);\n          } // Maybe some tempo?\n\n\n          if (typeof json.tempo !== 'undefined') {\n            conductor.setTempo(json.tempo);\n          } // Lets create some instruments\n\n\n          var instrumentList = {};\n\n          for (var instrument in json.instruments) {\n            if (!json.instruments.hasOwnProperty(instrument)) {\n              continue;\n            }\n\n            instrumentList[instrument] = conductor.createInstrument(json.instruments[instrument].name, json.instruments[instrument].pack);\n          } // Now lets add in each of the notes\n\n\n          for (var inst in json.notes) {\n            if (!json.notes.hasOwnProperty(inst)) {\n              continue;\n            }\n\n            var index = -1;\n\n            while (++index < json.notes[inst].length) {\n              var note = json.notes[inst][index]; // Use shorthand if it's a string\n\n              if (typeof note === 'string') {\n                var noteParts = note.split('|');\n\n                if ('rest' === noteParts[1]) {\n                  instrumentList[inst].rest(noteParts[0]);\n                } else {\n                  instrumentList[inst].note(noteParts[0], noteParts[1], noteParts[2]);\n                } // Otherwise use longhand\n\n              } else {\n                if ('rest' === note.type) {\n                  instrumentList[inst].rest(note.rhythm);\n                } else if ('note' === note.type) {\n                  instrumentList[inst].note(note.rhythm, note.pitch, note.tie);\n                }\n              }\n            }\n          } // Looks like we are done, lets press it.\n\n\n          return conductor.finish();\n        };\n        /**\r\n         * Create a new instrument\r\n         *\r\n         * @param [name] - defaults to sine\r\n         * @param [pack] - defaults to oscillators\r\n         */\n\n\n        conductor.createInstrument = function (name, pack) {\n          var Instrument = _dereq_('./instrument.js'),\n              instrument = new Instrument(name, pack, conductor);\n\n          conductor.instruments.push(instrument);\n          return instrument;\n        };\n        /**\r\n         * Needs to be called after all the instruments have been filled with notes.\r\n         * It will figure out the total duration of the song based on the longest\r\n         * duration out of all the instruments.  It will then pass back the Player Object\r\n         * which is used to control the music (play, stop, pause, loop, volume, tempo)\r\n         *\r\n         * It returns the Player object.\r\n         */\n\n\n        conductor.finish = function () {\n          var Player = _dereq_('./player.js');\n\n          player = new Player(conductor);\n          return player;\n        };\n        /**\r\n         * Remove all instruments and recreate AudioContext\r\n         */\n\n\n        conductor.destroy = function () {\n          conductor.audioContext = new AudioContext();\n          conductor.instruments.length = 0;\n          conductor.masterVolume = conductor.audioContext.createGain();\n          conductor.masterVolume.connect(conductor.audioContext.destination);\n        };\n        /**\r\n         * Set Master Volume\r\n         */\n\n\n        conductor.setMasterVolume = function (volume) {\n          if (volume > 1) {\n            volume = volume / 100;\n          }\n\n          conductor.masterVolumeLevel = volume;\n          conductor.masterVolume.gain.setValueAtTime(volume, conductor.audioContext.currentTime);\n        };\n        /**\r\n         * Grab the total duration of a song\r\n         *\r\n         * @returns {number}\r\n         */\n\n\n        conductor.getTotalSeconds = function () {\n          return Math.round(conductor.totalDuration);\n        };\n        /**\r\n         * Sets the ticker callback function. This function will be called\r\n         * every time the current seconds has changed.\r\n         *\r\n         * @param cb function\r\n         */\n\n\n        conductor.setTickerCallback = function (cb) {\n          if (typeof cb !== 'function') {\n            throw new Error('Ticker must be a function.');\n          }\n\n          conductor.onTickerCallback = cb;\n        };\n        /**\r\n         * Sets the time signature for the music. Just like in notation 4/4 time would be setTimeSignature(4, 4);\r\n         * @param top - Number of beats per bar\r\n         * @param bottom - What note type has the beat\r\n         */\n\n\n        conductor.setTimeSignature = function (top, bottom) {\n          if (typeof signatureToNoteLengthRatio[bottom] === 'undefined') {\n            throw new Error('The bottom time signature is not supported.');\n          } // Not used at the moment, but will be handy in the future.\n\n\n          conductor.beatsPerBar = top;\n          conductor.noteGetsBeat = signatureToNoteLengthRatio[bottom];\n        };\n        /**\r\n         * Sets the tempo\r\n         *\r\n         * @param t\r\n         */\n\n\n        conductor.setTempo = function (t) {\n          conductor.tempo = 60 / t; // If we have a player instance, we need to recalculate duration after resetting the tempo.\n\n          if (player) {\n            player.resetTempo();\n            conductor.onDurationChangeCallback();\n          }\n        };\n        /**\r\n         * Set a callback to fire when the song is finished\r\n         *\r\n         * @param cb\r\n         */\n\n\n        conductor.setOnFinishedCallback = function (cb) {\n          if (typeof cb !== 'function') {\n            throw new Error('onFinished callback must be a function.');\n          }\n\n          conductor.onFinishedCallback = cb;\n        };\n        /**\r\n         * Set a callback to fire when duration of a song changes\r\n         *\r\n         * @param cb\r\n         */\n\n\n        conductor.setOnDurationChangeCallback = function (cb) {\n          if (typeof cb !== 'function') {\n            throw new Error('onDurationChanged callback must be a function.');\n          }\n\n          conductor.onDurationChangeCallback = cb;\n        };\n        /**\r\n         * Set the number of notes that are buffered every (tempo / 60 * 5) seconds.\r\n         * It's set to 20 notes by default.\r\n         *\r\n         * **WARNING** The higher this is, the more memory is used and can crash your browser.\r\n         *             If notes are being dropped, you can increase this, but be weary of\r\n         *             used memory.\r\n         *\r\n         * @param {Integer} len\r\n         */\n\n\n        conductor.setNoteBufferLength = function (len) {\n          conductor.noteBufferLength = len;\n        };\n\n        conductor.setMasterVolume(100);\n        conductor.setTempo(120);\n        conductor.setTimeSignature(4, 4);\n      }\n\n      Conductor.loadPack = function (type, name, data) {\n        if (['tuning', 'rhythm', 'instrument'].indexOf(type) === -1) {\n          throw new Error(type + ' is not a valid Pack Type.');\n        }\n\n        if (typeof packs[type][name] !== 'undefined') {\n          throw new Error('A(n) ' + type + ' pack with the name \"' + name + '\" has already been loaded.');\n        }\n\n        packs[type][name] = data;\n      };\n    }, {\n      \"./instrument.js\": 5,\n      \"./player.js\": 7,\n      \"audiocontext\": 1\n    }],\n    3: [function (_dereq_, module, exports) {\n      /**\r\n       * Band.js - Music Composer\r\n       * An interface for the Web Audio API that supports rhythms, multiple instruments, repeating sections, and complex\r\n       * time signatures.\r\n       *\r\n       * @author Cody Lundquist (http://github.com/meenie) - 2014\r\n       */\n      module.exports = NoisesInstrumentPack;\n      /**\r\n       * Noises Instrument Pack\r\n       *\r\n       * Adapted from: https://github.com/zacharydenton/noise.js\r\n       *\r\n       * @param name\r\n       * @param audioContext\r\n       * @returns {{createNote: createNote}}\r\n       * @constructor\r\n       */\n\n      function NoisesInstrumentPack(name, audioContext) {\n        var types = ['white', 'pink', 'brown', 'brownian', 'red'];\n\n        if (types.indexOf(name) === -1) {\n          throw new Error(name + ' is not a valid noise sound');\n        }\n\n        return {\n          createNote: function (destination) {\n            switch (name) {\n              case 'white':\n                return createWhiteNoise(destination);\n\n              case 'pink':\n                return createPinkNoise(destination);\n\n              case 'brown':\n              case 'brownian':\n              case 'red':\n                return createBrownianNoise(destination);\n            }\n          }\n        };\n\n        function createWhiteNoise(destination) {\n          var bufferSize = 2 * audioContext.sampleRate,\n              noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate),\n              output = noiseBuffer.getChannelData(0);\n\n          for (var i = 0; i < bufferSize; i++) {\n            output[i] = Math.random() * 2 - 1;\n          }\n\n          var whiteNoise = audioContext.createBufferSource();\n          whiteNoise.buffer = noiseBuffer;\n          whiteNoise.loop = true;\n          whiteNoise.connect(destination);\n          return whiteNoise;\n        }\n\n        function createPinkNoise(destination) {\n          var bufferSize = 2 * audioContext.sampleRate,\n              noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate),\n              output = noiseBuffer.getChannelData(0),\n              b0,\n              b1,\n              b2,\n              b3,\n              b4,\n              b5,\n              b6;\n          b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\n          for (var i = 0; i < bufferSize; i++) {\n            var white = Math.random() * 2 - 1;\n            b0 = 0.99886 * b0 + white * 0.0555179;\n            b1 = 0.99332 * b1 + white * 0.0750759;\n            b2 = 0.96900 * b2 + white * 0.1538520;\n            b3 = 0.86650 * b3 + white * 0.3104856;\n            b4 = 0.55000 * b4 + white * 0.5329522;\n            b5 = -0.7616 * b5 - white * 0.0168980;\n            output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n            output[i] *= 0.11;\n            b6 = white * 0.115926;\n          }\n\n          var pinkNoise = audioContext.createBufferSource();\n          pinkNoise.buffer = noiseBuffer;\n          pinkNoise.loop = true;\n          pinkNoise.connect(destination);\n          return pinkNoise;\n        }\n\n        function createBrownianNoise(destination) {\n          var bufferSize = 2 * audioContext.sampleRate,\n              noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate),\n              output = noiseBuffer.getChannelData(0),\n              lastOut = 0.0;\n\n          for (var i = 0; i < bufferSize; i++) {\n            var white = Math.random() * 2 - 1;\n            output[i] = (lastOut + 0.02 * white) / 1.02;\n            lastOut = output[i];\n            output[i] *= 3.5;\n          }\n\n          var brownianNoise = audioContext.createBufferSource();\n          brownianNoise.buffer = noiseBuffer;\n          brownianNoise.loop = true;\n          brownianNoise.connect(destination);\n          return brownianNoise;\n        }\n      }\n    }, {}],\n    4: [function (_dereq_, module, exports) {\n      /**\r\n       * Band.js - Music Composer\r\n       * An interface for the Web Audio API that supports rhythms, multiple instruments, repeating sections, and complex\r\n       * time signatures.\r\n       *\r\n       * @author Cody Lundquist (http://github.com/meenie) - 2014\r\n       */\n      module.exports = OscillatorInstrumentPack;\n      /**\r\n       * Oscillator Instrument Pack\r\n       *\r\n       * @param name\r\n       * @param audioContext\r\n       * @returns {{createNote: createNote}}\r\n       * @constructor\r\n       */\n\n      function OscillatorInstrumentPack(name, audioContext) {\n        var types = ['sine', 'square', 'sawtooth', 'triangle'];\n\n        if (types.indexOf(name) === -1) {\n          throw new Error(name + ' is not a valid Oscillator type');\n        }\n\n        return {\n          createNote: function (destination, frequency) {\n            var o = audioContext.createOscillator(); // Connect note to volume\n\n            o.connect(destination); // Set pitch type\n\n            o.type = name; // Set frequency\n\n            o.frequency.value = frequency;\n            return o;\n          }\n        };\n      }\n    }, {}],\n    5: [function (_dereq_, module, exports) {\n      /**\r\n       * Band.js - Music Composer\r\n       * An interface for the Web Audio API that supports rhythms, multiple instruments, repeating sections, and complex\r\n       * time signatures.\r\n       *\r\n       * @author Cody Lundquist (http://github.com/meenie) - 2014\r\n       */\n      module.exports = Instrument;\n      /**\r\n       * Instrument Class - Gets instantiated when `Conductor.createInstrument()` is called.\r\n       *\r\n       * @param name\r\n       * @param pack\r\n       * @param conductor\r\n       * @constructor\r\n       */\n\n      function Instrument(name, pack, conductor) {\n        // Default to Sine Oscillator\n        if (!name) {\n          name = 'sine';\n        }\n\n        if (!pack) {\n          pack = 'oscillators';\n        }\n\n        if (typeof conductor.packs.instrument[pack] === 'undefined') {\n          throw new Error(pack + ' is not a currently loaded Instrument Pack.');\n        }\n        /**\r\n         * Helper function to figure out how long a note is\r\n         *\r\n         * @param rhythm\r\n         * @returns {number}\r\n         */\n\n\n        function getDuration(rhythm) {\n          if (typeof conductor.notes[rhythm] === 'undefined') {\n            throw new Error(rhythm + ' is not a correct rhythm.');\n          }\n\n          return conductor.notes[rhythm] * conductor.tempo / conductor.noteGetsBeat * 10;\n        }\n        /**\r\n         * Helper function to clone an object\r\n         *\r\n         * @param obj\r\n         * @returns {copy}\r\n         */\n\n\n        function clone(obj) {\n          if (null === obj || \"object\" != typeof obj) {\n            return obj;\n          }\n\n          var copy = obj.constructor();\n\n          for (var attr in obj) {\n            if (obj.hasOwnProperty(attr)) {\n              copy[attr] = obj[attr];\n            }\n          }\n\n          return copy;\n        }\n\n        var instrument = this,\n            lastRepeatCount = 0,\n            volumeLevel = 1,\n            articulationGapPercentage = 0.05;\n        instrument.totalDuration = 0;\n        instrument.bufferPosition = 0;\n        instrument.instrument = conductor.packs.instrument[pack](name, conductor.audioContext);\n        instrument.notes = [];\n        /**\r\n         * Set volume level for an instrument\r\n         *\r\n         * @param newVolumeLevel\r\n         */\n\n        instrument.setVolume = function (newVolumeLevel) {\n          if (newVolumeLevel > 1) {\n            newVolumeLevel = newVolumeLevel / 100;\n          }\n\n          volumeLevel = newVolumeLevel;\n          return instrument;\n        };\n        /**\r\n         * Add a note to an instrument\r\n         * @param rhythm\r\n         * @param [pitch] - Comma separated string if more than one pitch\r\n         * @param [tie]\r\n         */\n\n\n        instrument.note = function (rhythm, pitch, tie) {\n          var duration = getDuration(rhythm),\n              articulationGap = tie ? 0 : duration * articulationGapPercentage;\n\n          if (pitch) {\n            pitch = pitch.split(',');\n            var index = -1;\n\n            while (++index < pitch.length) {\n              var p = pitch[index];\n              p = p.trim();\n\n              if (typeof conductor.pitches[p] === 'undefined') {\n                p = parseFloat(p);\n\n                if (isNaN(p) || p < 0) {\n                  throw new Error(p + ' is not a valid pitch.');\n                }\n              }\n            }\n          }\n\n          instrument.notes.push({\n            rhythm: rhythm,\n            pitch: pitch,\n            duration: duration,\n            articulationGap: articulationGap,\n            tie: tie,\n            startTime: instrument.totalDuration,\n            stopTime: instrument.totalDuration + duration - articulationGap,\n            // Volume needs to be a quarter of the master so it doesn't clip\n            volumeLevel: volumeLevel / 4\n          });\n          instrument.totalDuration += duration;\n          return instrument;\n        };\n        /**\r\n         * Add a rest to an instrument\r\n         *\r\n         * @param rhythm\r\n         */\n\n\n        instrument.rest = function (rhythm) {\n          var duration = getDuration(rhythm);\n          instrument.notes.push({\n            rhythm: rhythm,\n            pitch: false,\n            duration: duration,\n            articulationGap: 0,\n            startTime: instrument.totalDuration,\n            stopTime: instrument.totalDuration + duration\n          });\n          instrument.totalDuration += duration;\n          return instrument;\n        };\n        /**\r\n         * Place where a repeat section should start\r\n         */\n\n\n        instrument.repeatStart = function () {\n          lastRepeatCount = instrument.notes.length;\n          return instrument;\n        };\n        /**\r\n         * Repeat from beginning\r\n         */\n\n\n        instrument.repeatFromBeginning = function (numOfRepeats) {\n          lastRepeatCount = 0;\n          instrument.repeat(numOfRepeats);\n          return instrument;\n        };\n        /**\r\n         * Number of times the section should repeat\r\n         * @param [numOfRepeats] - defaults to 1\r\n         */\n\n\n        instrument.repeat = function (numOfRepeats) {\n          numOfRepeats = typeof numOfRepeats === 'undefined' ? 1 : numOfRepeats;\n          var notesBufferCopy = instrument.notes.slice(lastRepeatCount);\n\n          for (var r = 0; r < numOfRepeats; r++) {\n            var index = -1;\n\n            while (++index < notesBufferCopy.length) {\n              var noteCopy = clone(notesBufferCopy[index]);\n              noteCopy.startTime = instrument.totalDuration;\n              noteCopy.stopTime = instrument.totalDuration + noteCopy.duration - noteCopy.articulationGap;\n              instrument.notes.push(noteCopy);\n              instrument.totalDuration += noteCopy.duration;\n            }\n          }\n\n          return instrument;\n        };\n        /**\r\n         * Reset the duration, start, and stop time of each note.\r\n         */\n\n\n        instrument.resetDuration = function () {\n          var index = -1,\n              numOfNotes = instrument.notes.length;\n          instrument.totalDuration = 0;\n\n          while (++index < numOfNotes) {\n            var note = instrument.notes[index],\n                duration = getDuration(note.rhythm),\n                articulationGap = note.tie ? 0 : duration * articulationGapPercentage;\n            note.duration = getDuration(note.rhythm);\n            note.startTime = instrument.totalDuration;\n            note.stopTime = instrument.totalDuration + duration - articulationGap;\n\n            if (note.pitch !== false) {\n              note.articulationGap = articulationGap;\n            }\n\n            instrument.totalDuration += duration;\n          }\n        };\n      }\n    }, {}],\n    6: [function (_dereq_, module, exports) {\n      /**\r\n       * Band.js - Music Composer\r\n       * An interface for the Web Audio API that supports rhythms, multiple instruments, repeating sections, and complex\r\n       * time signatures.\r\n       *\r\n       * @author Cody Lundquist (http://github.com/meenie) - 2014\r\n       */\n\n      /**\r\n       * @type {BandJS}\r\n       */\n      module.exports = _dereq_('./conductor.js');\n      module.exports.loadPack('instrument', 'noises', _dereq_('./instrument-packs/noises.js'));\n      module.exports.loadPack('instrument', 'oscillators', _dereq_('./instrument-packs/oscillators.js'));\n      module.exports.loadPack('rhythm', 'northAmerican', _dereq_('./rhythm-packs/north-american.js'));\n      module.exports.loadPack('rhythm', 'european', _dereq_('./rhythm-packs/european.js'));\n      module.exports.loadPack('tuning', 'equalTemperament', _dereq_('./tuning-packs/equal-temperament.js'));\n    }, {\n      \"./conductor.js\": 2,\n      \"./instrument-packs/noises.js\": 3,\n      \"./instrument-packs/oscillators.js\": 4,\n      \"./rhythm-packs/european.js\": 8,\n      \"./rhythm-packs/north-american.js\": 9,\n      \"./tuning-packs/equal-temperament.js\": 10\n    }],\n    7: [function (_dereq_, module, exports) {\n      /**\r\n       * Band.js - Music Composer\r\n       * An interface for the Web Audio API that supports rhythms, multiple instruments, repeating sections, and complex\r\n       * time signatures.\r\n       *\r\n       * @author Cody Lundquist (http://github.com/meenie) - 2014\r\n       */\n      module.exports = Player;\n      /**\r\n       * Player Class - This gets instantiated by the Conductor class when `Conductor.finish()` is called\r\n       *\r\n       * @param conductor\r\n       * @constructor\r\n       */\n\n      function Player(conductor) {\n        var player = this,\n            bufferTimeout,\n            allNotes = bufferNotes(),\n            currentPlayTime,\n            totalPlayTime = 0,\n            faded = false;\n        calculateTotalDuration();\n        /**\r\n         * Helper function to stop all notes and\r\n         * then re-buffers them\r\n         *\r\n         * @param {Boolean} [resetDuration]\r\n         */\n\n        function reset(resetDuration) {\n          // Reset the buffer position of all instruments\n          var index = -1,\n              numOfInstruments = conductor.instruments.length;\n\n          while (++index < numOfInstruments) {\n            var instrument = conductor.instruments[index];\n\n            if (resetDuration) {\n              instrument.resetDuration();\n            }\n\n            instrument.bufferPosition = 0;\n          } // If we are reseting the duration, we need to figure out the new total duration.\n          // Also set the totalPlayTime to the current percentage done of the new total duration.\n\n\n          if (resetDuration) {\n            calculateTotalDuration();\n            totalPlayTime = conductor.percentageComplete * conductor.totalDuration;\n          }\n\n          index = -1;\n\n          while (++index < allNotes.length) {\n            allNotes[index].gain.disconnect();\n          }\n\n          clearTimeout(bufferTimeout);\n          allNotes = bufferNotes();\n        }\n        /**\r\n         * Helper function to fade up/down master volume\r\n         *\r\n         * @param direction - up or down\r\n         * @param [cb] - Callback function fired after the transition is completed\r\n         * @param [resetVolume] - Reset the volume back to it's original level\r\n         */\n\n\n        function fade(direction, cb, resetVolume) {\n          if (typeof resetVolume === 'undefined') {\n            resetVolume = false;\n          }\n\n          if ('up' !== direction && 'down' !== direction) {\n            throw new Error('Direction must be either up or down.');\n          }\n\n          var fadeDuration = 0.2;\n          faded = direction === 'down';\n\n          if (direction === 'up') {\n            conductor.masterVolume.gain.linearRampToValueAtTime(0, conductor.audioContext.currentTime);\n            conductor.masterVolume.gain.linearRampToValueAtTime(conductor.masterVolumeLevel, conductor.audioContext.currentTime + fadeDuration);\n          } else {\n            conductor.masterVolume.gain.linearRampToValueAtTime(conductor.masterVolumeLevel, conductor.audioContext.currentTime);\n            conductor.masterVolume.gain.linearRampToValueAtTime(0, conductor.audioContext.currentTime + fadeDuration);\n          }\n\n          setTimeout(function () {\n            if (typeof cb === 'function') {\n              cb.call(player);\n            }\n\n            if (resetVolume) {\n              faded = !faded;\n              conductor.masterVolume.gain.linearRampToValueAtTime(conductor.masterVolumeLevel, conductor.audioContext.currentTime);\n            }\n          }, fadeDuration * 1000);\n        }\n        /**\r\n         * Calculates the total duration of a song based on the longest duration of all instruments.\r\n         */\n\n\n        function calculateTotalDuration() {\n          var index = -1;\n          var totalDuration = 0;\n\n          while (++index < conductor.instruments.length) {\n            var instrument = conductor.instruments[index];\n\n            if (instrument.totalDuration > totalDuration) {\n              totalDuration = instrument.totalDuration;\n            }\n          }\n\n          conductor.totalDuration = totalDuration;\n        }\n        /**\r\n         * Grabs a set of notes based on the current time and what the Buffer Size is.\r\n         * It will also skip any notes that have a start time less than the\r\n         * total play time.\r\n         *\r\n         * @returns {Array}\r\n         */\n\n\n        function bufferNotes() {\n          var notes = [],\n              index = -1,\n              bufferSize = conductor.noteBufferLength;\n\n          while (++index < conductor.instruments.length) {\n            var instrument = conductor.instruments[index]; // Create volume for this instrument\n\n            var bufferCount = bufferSize;\n            var index2 = -1;\n\n            while (++index2 < bufferCount) {\n              var note = instrument.notes[instrument.bufferPosition + index2];\n\n              if (typeof note === 'undefined') {\n                break;\n              }\n\n              var pitch = note.pitch,\n                  startTime = note.startTime,\n                  stopTime = note.stopTime,\n                  volumeLevel = note.volumeLevel;\n\n              if (stopTime < totalPlayTime) {\n                bufferCount++;\n                continue;\n              } // If pitch is false, then it's a rest and we don't need a note\n\n\n              if (false === pitch) {\n                continue;\n              }\n\n              var gain = conductor.audioContext.createGain(); // Connect volume gain to the Master Volume;\n\n              gain.connect(conductor.masterVolume);\n              gain.gain.value = volumeLevel; // If the startTime is less than total play time, we need to start the note\n              // in the middle\n\n              if (startTime < totalPlayTime) {\n                startTime = stopTime - totalPlayTime;\n              } // No pitches defined\n\n\n              if (typeof pitch === 'undefined') {\n                notes.push({\n                  startTime: startTime < totalPlayTime ? stopTime - totalPlayTime : startTime,\n                  stopTime: stopTime,\n                  node: instrument.instrument.createNote(gain),\n                  gain: gain,\n                  volumeLevel: volumeLevel\n                });\n              } else {\n                var index3 = -1;\n\n                while (++index3 < pitch.length) {\n                  var p = pitch[index3];\n                  notes.push({\n                    startTime: startTime,\n                    stopTime: stopTime,\n                    node: instrument.instrument.createNote(gain, conductor.pitches[p.trim()] || parseFloat(p)),\n                    gain: gain,\n                    volumeLevel: volumeLevel\n                  });\n                }\n              }\n            }\n\n            instrument.bufferPosition += bufferCount;\n          } // Return array of notes\n\n\n          return notes;\n        }\n\n        function totalPlayTimeCalculator() {\n          if (!player.paused && player.playing) {\n            if (conductor.totalDuration < totalPlayTime) {\n              player.stop(false);\n\n              if (player.looping) {\n                player.play();\n              } else {\n                conductor.onFinishedCallback();\n              }\n            } else {\n              updateTotalPlayTime();\n              setTimeout(totalPlayTimeCalculator, 1000 / 60);\n            }\n          }\n        }\n        /**\r\n         * Call to update the total play time so far\r\n         */\n\n\n        function updateTotalPlayTime() {\n          totalPlayTime += conductor.audioContext.currentTime - currentPlayTime;\n          var seconds = Math.round(totalPlayTime);\n\n          if (seconds != conductor.currentSeconds) {\n            // Make callback asynchronous\n            setTimeout(function () {\n              conductor.onTickerCallback(seconds);\n            }, 1);\n            conductor.currentSeconds = seconds;\n          }\n\n          conductor.percentageComplete = totalPlayTime / conductor.totalDuration;\n          currentPlayTime = conductor.audioContext.currentTime;\n        }\n\n        player.paused = false;\n        player.playing = false;\n        player.looping = false;\n        player.muted = false;\n        /**\r\n         * Grabs currently buffered notes and calls their start/stop methods.\r\n         *\r\n         * It then sets up a timer to buffer up the next set of notes based on the\r\n         * a set buffer size.  This will keep going until the song is stopped or paused.\r\n         *\r\n         * It will use the total time played so far as an offset so you pause/play the music\r\n         */\n\n        player.play = function () {\n          player.playing = true;\n          player.paused = false;\n          currentPlayTime = conductor.audioContext.currentTime; // Starts calculator which keeps track of total play time\n\n          totalPlayTimeCalculator();\n\n          var timeOffset = conductor.audioContext.currentTime - totalPlayTime,\n              playNotes = function (notes) {\n            var index = -1;\n\n            while (++index < notes.length) {\n              var note = notes[index];\n              var startTime = note.startTime + timeOffset,\n                  stopTime = note.stopTime + timeOffset;\n              /**\r\n               * If no tie, then we need to introduce a volume ramp up to remove any clipping\r\n               * as Oscillators have an issue with this when playing a note at full volume.\r\n               * We also put in a slight ramp down as well.  This only takes up 1/1000 of a second.\r\n               */\n\n              if (!note.tie) {\n                if (startTime > 0) {\n                  startTime -= 0.001;\n                }\n\n                stopTime += 0.001;\n                note.gain.gain.setValueAtTime(0.0, startTime);\n                note.gain.gain.linearRampToValueAtTime(note.volumeLevel, startTime + 0.001);\n                note.gain.gain.setValueAtTime(note.volumeLevel, stopTime - 0.001);\n                note.gain.gain.linearRampToValueAtTime(0.0, stopTime);\n              }\n\n              note.node.start(startTime);\n              note.node.stop(stopTime);\n            }\n          },\n              bufferUp = function () {\n            bufferTimeout = setTimeout(function bufferInNewNotes() {\n              if (player.playing && !player.paused) {\n                var newNotes = bufferNotes();\n\n                if (newNotes.length > 0) {\n                  playNotes(newNotes);\n                  allNotes = allNotes.concat(newNotes);\n                  bufferUp();\n                }\n              }\n            }, conductor.tempo * 5000);\n          };\n\n          playNotes(allNotes);\n          bufferUp();\n\n          if (faded && !player.muted) {\n            fade('up');\n          }\n        };\n        /**\r\n         * Stop playing all music and rewind the song\r\n         *\r\n         * @param fadeOut boolean - should the song fade out?\r\n         */\n\n\n        player.stop = function (fadeOut) {\n          player.playing = false;\n          conductor.currentSeconds = 0;\n          conductor.percentageComplete = 0;\n\n          if (typeof fadeOut === 'undefined') {\n            fadeOut = true;\n          }\n\n          if (fadeOut && !player.muted) {\n            fade('down', function () {\n              totalPlayTime = 0;\n              reset(); // Make callback asynchronous\n\n              setTimeout(function () {\n                conductor.onTickerCallback(conductor.currentSeconds);\n              }, 1);\n            }, true);\n          } else {\n            totalPlayTime = 0;\n            reset(); // Make callback asynchronous\n\n            setTimeout(function () {\n              conductor.onTickerCallback(conductor.currentSeconds);\n            }, 1);\n          }\n        };\n        /**\r\n         * Pauses the music, resets the notes,\r\n         * and gets the total time played so far\r\n         */\n\n\n        player.pause = function () {\n          player.paused = true;\n          updateTotalPlayTime();\n\n          if (player.muted) {\n            reset();\n          } else {\n            fade('down', function () {\n              reset();\n            });\n          }\n        };\n        /**\r\n         * Set true if you want the song to loop\r\n         *\r\n         * @param val\r\n         */\n\n\n        player.loop = function (val) {\n          player.looping = !!val;\n        };\n        /**\r\n         * Set a specific time that the song should start it.\r\n         * If it's already playing, reset and start the song\r\n         * again so it has a seamless jump.\r\n         *\r\n         * @param newTime\r\n         */\n\n\n        player.setTime = function (newTime) {\n          totalPlayTime = parseInt(newTime);\n          reset();\n\n          if (player.playing && !player.paused) {\n            player.play();\n          }\n        };\n        /**\r\n         * Reset the tempo for a song. This will trigger a\r\n         * duration reset for each instrument as well.\r\n         */\n\n\n        player.resetTempo = function () {\n          reset(true);\n\n          if (player.playing && !player.paused) {\n            player.play();\n          }\n        };\n        /**\r\n         * Mute all of the music\r\n         *\r\n         * @param cb - Callback function called when music has been muted\r\n         */\n\n\n        player.mute = function (cb) {\n          player.muted = true;\n          fade('down', cb);\n        };\n        /**\r\n         * Unmute all of the music\r\n         *\r\n         * @param cb - Callback function called when music has been unmuted\r\n         */\n\n\n        player.unmute = function (cb) {\n          player.muted = false;\n          fade('up', cb);\n        };\n      }\n    }, {}],\n    8: [function (_dereq_, module, exports) {\n      /**\r\n       * Band.js - Music Composer\r\n       * An interface for the Web Audio API that supports rhythms, multiple instruments, repeating sections, and complex\r\n       * time signatures.\r\n       *\r\n       * @author Cody Lundquist (http://github.com/meenie) - 2014\r\n       */\n\n      /**\r\n       * European Rhythm Pack\r\n       */\n      module.exports = {\n        semibreve: 1,\n        dottedMinim: 0.75,\n        minim: 0.5,\n        dottedCrotchet: 0.375,\n        tripletMinim: 0.33333334,\n        crotchet: 0.25,\n        dottedQuaver: 0.1875,\n        tripletCrotchet: 0.166666667,\n        quaver: 0.125,\n        dottedSemiquaver: 0.09375,\n        tripletQuaver: 0.083333333,\n        semiquaver: 0.0625,\n        tripletSemiquaver: 0.041666667,\n        demisemiquaver: 0.03125\n      };\n    }, {}],\n    9: [function (_dereq_, module, exports) {\n      /**\r\n       * Band.js - Music Composer\r\n       * An interface for the Web Audio API that supports rhythms, multiple instruments, repeating sections, and complex\r\n       * time signatures.\r\n       *\r\n       * @author Cody Lundquist (http://github.com/meenie) - 2014\r\n       */\n\n      /**\r\n       * North American (Canada and USA) Rhythm Pack\r\n       */\n      module.exports = {\n        whole: 1,\n        dottedHalf: 0.75,\n        half: 0.5,\n        dottedQuarter: 0.375,\n        tripletHalf: 0.33333334,\n        quarter: 0.25,\n        dottedEighth: 0.1875,\n        tripletQuarter: 0.166666667,\n        eighth: 0.125,\n        dottedSixteenth: 0.09375,\n        tripletEighth: 0.083333333,\n        sixteenth: 0.0625,\n        tripletSixteenth: 0.041666667,\n        thirtySecond: 0.03125\n      };\n    }, {}],\n    10: [function (_dereq_, module, exports) {\n      /**\r\n       * Band.js - Music Composer\r\n       * An interface for the Web Audio API that supports rhythms, multiple instruments, repeating sections, and complex\r\n       * time signatures.\r\n       *\r\n       * @author Cody Lundquist (http://github.com/meenie) - 2014\r\n       */\n\n      /**\r\n       * Equal Temperament Tuning\r\n       * Source: http://www.phy.mtu.edu/~suits/notefreqs.html\r\n       */\n      module.exports = {\n        'C0': 16.35,\n        'C#0': 17.32,\n        'Db0': 17.32,\n        'D0': 18.35,\n        'D#0': 19.45,\n        'Eb0': 19.45,\n        'E0': 20.60,\n        'F0': 21.83,\n        'F#0': 23.12,\n        'Gb0': 23.12,\n        'G0': 24.50,\n        'G#0': 25.96,\n        'Ab0': 25.96,\n        'A0': 27.50,\n        'A#0': 29.14,\n        'Bb0': 29.14,\n        'B0': 30.87,\n        'C1': 32.70,\n        'C#1': 34.65,\n        'Db1': 34.65,\n        'D1': 36.71,\n        'D#1': 38.89,\n        'Eb1': 38.89,\n        'E1': 41.20,\n        'F1': 43.65,\n        'F#1': 46.25,\n        'Gb1': 46.25,\n        'G1': 49.00,\n        'G#1': 51.91,\n        'Ab1': 51.91,\n        'A1': 55.00,\n        'A#1': 58.27,\n        'Bb1': 58.27,\n        'B1': 61.74,\n        'C2': 65.41,\n        'C#2': 69.30,\n        'Db2': 69.30,\n        'D2': 73.42,\n        'D#2': 77.78,\n        'Eb2': 77.78,\n        'E2': 82.41,\n        'F2': 87.31,\n        'F#2': 92.50,\n        'Gb2': 92.50,\n        'G2': 98.00,\n        'G#2': 103.83,\n        'Ab2': 103.83,\n        'A2': 110.00,\n        'A#2': 116.54,\n        'Bb2': 116.54,\n        'B2': 123.47,\n        'C3': 130.81,\n        'C#3': 138.59,\n        'Db3': 138.59,\n        'D3': 146.83,\n        'D#3': 155.56,\n        'Eb3': 155.56,\n        'E3': 164.81,\n        'F3': 174.61,\n        'F#3': 185.00,\n        'Gb3': 185.00,\n        'G3': 196.00,\n        'G#3': 207.65,\n        'Ab3': 207.65,\n        'A3': 220.00,\n        'A#3': 233.08,\n        'Bb3': 233.08,\n        'B3': 246.94,\n        'C4': 261.63,\n        'C#4': 277.18,\n        'Db4': 277.18,\n        'D4': 293.66,\n        'D#4': 311.13,\n        'Eb4': 311.13,\n        'E4': 329.63,\n        'F4': 349.23,\n        'F#4': 369.99,\n        'Gb4': 369.99,\n        'G4': 392.00,\n        'G#4': 415.30,\n        'Ab4': 415.30,\n        'A4': 440.00,\n        'A#4': 466.16,\n        'Bb4': 466.16,\n        'B4': 493.88,\n        'C5': 523.25,\n        'C#5': 554.37,\n        'Db5': 554.37,\n        'D5': 587.33,\n        'D#5': 622.25,\n        'Eb5': 622.25,\n        'E5': 659.26,\n        'F5': 698.46,\n        'F#5': 739.99,\n        'Gb5': 739.99,\n        'G5': 783.99,\n        'G#5': 830.61,\n        'Ab5': 830.61,\n        'A5': 880.00,\n        'A#5': 932.33,\n        'Bb5': 932.33,\n        'B5': 987.77,\n        'C6': 1046.50,\n        'C#6': 1108.73,\n        'Db6': 1108.73,\n        'D6': 1174.66,\n        'D#6': 1244.51,\n        'Eb6': 1244.51,\n        'E6': 1318.51,\n        'F6': 1396.91,\n        'F#6': 1479.98,\n        'Gb6': 1479.98,\n        'G6': 1567.98,\n        'G#6': 1661.22,\n        'Ab6': 1661.22,\n        'A6': 1760.00,\n        'A#6': 1864.66,\n        'Bb6': 1864.66,\n        'B6': 1975.53,\n        'C7': 2093.00,\n        'C#7': 2217.46,\n        'Db7': 2217.46,\n        'D7': 2349.32,\n        'D#7': 2489.02,\n        'Eb7': 2489.02,\n        'E7': 2637.02,\n        'F7': 2793.83,\n        'F#7': 2959.96,\n        'Gb7': 2959.96,\n        'G7': 3135.96,\n        'G#7': 3322.44,\n        'Ab7': 3322.44,\n        'A7': 3520.00,\n        'A#7': 3729.31,\n        'Bb7': 3729.31,\n        'B7': 3951.07,\n        'C8': 4186.01\n      };\n    }, {}]\n  }, {}, [6])(6);\n});","map":null,"metadata":{},"sourceType":"script"}